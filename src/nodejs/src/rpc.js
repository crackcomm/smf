// automatically generated by the FlatBuffers compiler, do not modify

/**
 * @const
 * @namespace
 */
var rpc = module.exports = {};

/**
 * \brief: headers that are stored in an int
 * so they need to be inclusive. That is, you can turn on
 * many flags at the same time, i.e.: enable checksum and
 * have the payload be zlib compressed.
 *
 *
 * @enum
 */
rpc.compression_flags = {
  none: 0,
  disabled: 1,
  zstd: 2,
  lz4: 3
};

/**
 * @enum
 */
rpc.header_bit_flags = {
  has_payload_headers: 1
};

/**
 * \brief: header parsed by rpc engine
 * must be sizeof()'able
 * that is, must be a struct in fbs language
 *
 * layout
 * [ 8bits(compression) + 8bits(bitflags) + 16bits(session) + 32bits(size) + 32bits(checksum) + 32bits(meta) ]
 * total = 128bits == 16bytes
 *
 *
 * @constructor
 */
rpc.header = function () {
  /**
   * @type {flatbuffers.ByteBuffer}
   */
  this.bb = null;

  /**
   * @type {number}
   */
  this.bb_pos = 0;
};

/**
 * @param {number} i
 * @param {flatbuffers.ByteBuffer} bb
 * @returns {rpc.header}
 */
rpc.header.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param {flatbuffers.ByteBuffer} bb
 * @returns {rpc.header}
 */
rpc.header.getRootAsHeader = function (bb) {
  return (new rpc.header).__init(0, bb);
};

/**
 * @returns {rpc.compression_flags}
 */
rpc.header.prototype.compression = function () {
  return /** @type {rpc.compression_flags} */ (this.bb.readInt8(this.bb_pos));
};

/**
 * @returns {rpc.header_bit_flags}
 */
rpc.header.prototype.bitflags = function () {
  return /** @type {rpc.header_bit_flags} */ (this.bb.readInt8(this.bb_pos + 1));
};

/**
 * 16 bits for storing the actual session id.
 * used for streaming client and slot allocation
 *
 * @returns {number}
 */
rpc.header.prototype.session = function () {
  return this.bb.readUint16(this.bb_pos + 2);
};

/**
 * size of the next payload
 *
 * @returns {number}
 */
rpc.header.prototype.size = function () {
  return this.bb.readUint32(this.bb_pos + 4);
};

/**
 * currently we use (xxhash64 & UINT32_MAX)
 *
 * @returns {number}
 */
rpc.header.prototype.checksum = function () {
  return this.bb.readUint32(this.bb_pos + 8);
};

/**
 * \brief used for sending and receiving, read carefully.
 *
 * Receiving:
 *
 * Uses the same as HTTP status - on the receiving end
 * We don't want to pay the cost of parsing a header
 * On every response as does HTTP. std::to_string and std::stol()
 * are needlesly expensive
 *
 * Sending:
 *
 * Used with the xor hash of Service::ID() ^ Service::Method::ID()
 * This is how the server multiplexer figures out what function pointer
 * to call
 *
 *
 * @returns {number}
 */
rpc.header.prototype.meta = function () {
  return this.bb.readUint32(this.bb_pos + 12);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {rpc.compression_flags} compression
 * @param {rpc.header_bit_flags} bitflags
 * @param {number} session
 * @param {number} size
 * @param {number} checksum
 * @param {number} meta
 * @returns {flatbuffers.Offset}
 */
rpc.header.createheader = function (builder, compression, bitflags, session, size, checksum, meta) {
  builder.prep(4, 16);
  builder.writeInt32(meta);
  builder.writeInt32(checksum);
  builder.writeInt32(size);
  builder.writeInt16(session);
  builder.writeInt8(bitflags);
  builder.writeInt8(compression);
  return builder.offset();
};

/**
 * \brief used for extra headers, ala HTTP
 * The use case for the core is to support
 * zipkin/google-Dapper style tracing
 *
 * @constructor
 */
rpc.dynamic_header = function () {
  /**
   * @type {flatbuffers.ByteBuffer}
   */
  this.bb = null;

  /**
   * @type {number}
   */
  this.bb_pos = 0;
};

/**
 * @param {number} i
 * @param {flatbuffers.ByteBuffer} bb
 * @returns {rpc.dynamic_header}
 */
rpc.dynamic_header.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param {flatbuffers.ByteBuffer} bb
 * @param {rpc.dynamic_header=} obj
 * @returns {rpc.dynamic_header}
 */
rpc.dynamic_header.getRootAsdynamic_header = function (bb, obj) {
  return (obj || new rpc.dynamic_header).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * alows for binary search lookup
 * use with CreateVectorOfSortedTables<> instead of the CreateVector
 *
 * @param {flatbuffers.Encoding=} optionalEncoding
 * @returns {string|Uint8Array|null}
 */
rpc.dynamic_header.prototype.key = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * @param {flatbuffers.Encoding=} optionalEncoding
 * @returns {string|Uint8Array|null}
 */
rpc.dynamic_header.prototype.value = function (optionalEncoding) {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * @param {flatbuffers.Builder} builder
 */
rpc.dynamic_header.startdynamic_header = function (builder) {
  builder.startObject(2);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {flatbuffers.Offset} keyOffset
 */
rpc.dynamic_header.addKey = function (builder, keyOffset) {
  builder.addFieldOffset(0, keyOffset, 0);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {flatbuffers.Offset} valueOffset
 */
rpc.dynamic_header.addValue = function (builder, valueOffset) {
  builder.addFieldOffset(1, valueOffset, 0);
};

/**
 * @param {flatbuffers.Builder} builder
 * @returns {flatbuffers.Offset}
 */
rpc.dynamic_header.enddynamic_header = function (builder) {
  var offset = builder.endObject();
  builder.requiredField(offset, 4); // key
  return offset;
};

/**
 * @constructor
 */
rpc.payload_headers = function () {
  /**
   * @type {flatbuffers.ByteBuffer}
   */
  this.bb = null;

  /**
   * @type {number}
   */
  this.bb_pos = 0;
};

/**
 * @param {number} i
 * @param {flatbuffers.ByteBuffer} bb
 * @returns {rpc.payload_headers}
 */
rpc.payload_headers.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param {flatbuffers.ByteBuffer} bb
 * @param {rpc.payload_headers=} obj
 * @returns {rpc.payload_headers}
 */
rpc.payload_headers.getRootAspayload_headers = function (bb, obj) {
  return (obj || new rpc.payload_headers).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Headers for forward compat.
 *
 * @param {number} index
 * @param {rpc.dynamic_header=} obj
 * @returns {rpc.dynamic_header}
 */
rpc.payload_headers.prototype.dynamicHeaders = function (index, obj) {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? (obj || new rpc.dynamic_header).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
};

/**
 * @returns {number}
 */
rpc.payload_headers.prototype.dynamicHeadersLength = function () {
  var offset = this.bb.__offset(this.bb_pos, 4);
  return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * We need to chain the actual payload
 *
 * @returns {number}
 */
rpc.payload_headers.prototype.size = function () {
  var offset = this.bb.__offset(this.bb_pos, 6);
  return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
};

/**
 * @returns {number}
 */
rpc.payload_headers.prototype.checksum = function () {
  var offset = this.bb.__offset(this.bb_pos, 8);
  return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
};

/**
 * @returns {rpc.compression_flags}
 */
rpc.payload_headers.prototype.compression = function () {
  var offset = this.bb.__offset(this.bb_pos, 10);
  return offset ? /** @type {rpc.compression_flags} */ (this.bb.readInt8(this.bb_pos + offset)) : rpc.compression_flags.none;
};

/**
 * @param {flatbuffers.Builder} builder
 */
rpc.payload_headers.startpayload_headers = function (builder) {
  builder.startObject(4);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {flatbuffers.Offset} dynamicHeadersOffset
 */
rpc.payload_headers.addDynamicHeaders = function (builder, dynamicHeadersOffset) {
  builder.addFieldOffset(0, dynamicHeadersOffset, 0);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {Array.<flatbuffers.Offset>} data
 * @returns {flatbuffers.Offset}
 */
rpc.payload_headers.createDynamicHeadersVector = function (builder, data) {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {number} numElems
 */
rpc.payload_headers.startDynamicHeadersVector = function (builder, numElems) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {number} size
 */
rpc.payload_headers.addSize = function (builder, size) {
  builder.addFieldInt32(1, size, 0);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {number} checksum
 */
rpc.payload_headers.addChecksum = function (builder, checksum) {
  builder.addFieldInt32(2, checksum, 0);
};

/**
 * @param {flatbuffers.Builder} builder
 * @param {rpc.compression_flags} compression
 */
rpc.payload_headers.addCompression = function (builder, compression) {
  builder.addFieldInt8(3, compression, rpc.compression_flags.none);
};

/**
 * @param {flatbuffers.Builder} builder
 * @returns {flatbuffers.Offset}
 */
rpc.payload_headers.endpayload_headers = function (builder) {
  var offset = builder.endObject();
  return offset;
};

/**
 * \brief, useful when the type is empty
 * i.e.: void foo();
 * rpc my_rpc { null_type MutateOnlyOnServerMethod(int); }
 *
 *
 * @constructor
 */
rpc.null_type = function () {
  /**
   * @type {flatbuffers.ByteBuffer}
   */
  this.bb = null;

  /**
   * @type {number}
   */
  this.bb_pos = 0;
};

/**
 * @param {number} i
 * @param {flatbuffers.ByteBuffer} bb
 * @returns {rpc.null_type}
 */
rpc.null_type.prototype.__init = function (i, bb) {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param {flatbuffers.ByteBuffer} bb
 * @param {rpc.null_type=} obj
 * @returns {rpc.null_type}
 */
rpc.null_type.getRootAsnull_type = function (bb, obj) {
  return (obj || new rpc.null_type).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param {flatbuffers.Builder} builder
 */
rpc.null_type.startnull_type = function (builder) {
  builder.startObject(0);
};

/**
 * @param {flatbuffers.Builder} builder
 * @returns {flatbuffers.Offset}
 */
rpc.null_type.endnull_type = function (builder) {
  var offset = builder.endObject();
  return offset;
};
